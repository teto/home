-- TypeError (ShowType r)

CABAL_HELPER_DEBUG=1
{-# OPTIONS_GHC -fdefer-type-errors #-}
{-# OPTIONS_GHC -Wno-missing-signatures #-}

 `:reload!` ajoute automatiquement -fdefer-type-errors

:load impore tous les symboles (!= `import`)
-dppr-cols2000 to control the width of error messages in ghci

time brun --config debug //luad-s2ands5-simulation:MultipleClonesTumors@run -- +RTS -p -s -hy -l-au

# working with ghc-pkg
ghc-pkg init ./test.db
ghc-pkg list --global  (vs user)

https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/packages.html#package-environments

-package-env

Or GHC_ENVIRONMENT
GHC_PACKAGE_PATH
/home/teto/.ghc/x86_64-linux-8.10.7/environments/default

https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/packages.html#package-databases

:xa
cabal install --lib ./servant-openapi3.cabal --package-env ./foo
cabal install --lib
ghc-pkg register --user --force /home/teto/nova/servant-openapi3/dist-newstyle/build/x86_64-linux/ghc-8.10.7/servant-openapi3-2.0.1.3/package.conf.inplace/servant-openapi3-2.0.1.3-inplace.conf 

https://stackoverflow.com/questions/55379400/how-to-generate-a-ghc-database-for-one-package

cabal haddock --haddock-executables

# How to convert between Text/String/ByteString
import Data.Text.Encoding
https://stackoverflow.com/questions/3232074/what-is-the-best-way-to-convert-string-to-bytestring
https://gist.github.com/dino-/28b09c465c756c44b2c91d777408e166

## string <-> Bytestring
BLU.toString   :: BL.ByteString -> String
BLU.fromString :: String -> BL.ByteString
lazyByteString = BLU.fromString "lazyByteString ä ß"

pour savoir d'ou le pkg est importe:
	ghc-pkg find-module System.Linux.Netlink

in ghci :
:show paths

Generate database with:
$ ghc-pkg -v -f /home/teto/netlink-hs  recache


How to configure cabal ?
https://www.haskell.org/cabal/users-guide/installing-packages.html
$ cabal user-config update

see https://wiki.haskell.org/FAQ#How_can_I_get_a_stack_backtrace_when_my_program_throws_an_exception.3F

    -- -fno-warn-unused-imports 
    -- -fforce-recomp  makes it build twice on nixos
    ghc-options: -Wall -fno-warn-unused-binds -fno-warn-unused-matches -threaded -fprof-auto -rtsopts

AWSInfo{..} = RecordWildCards

# to disable errors
{-# OPTIONS_GHC -fno-warn-orphans #-}

# to select only some fields in a record: RecordWildCards
record{..} will bring everything intoScope
A better alternative is (tcpInfo@DiagTcpInfo {} )


# acronyms
NT = natural transformation


# how to debug timing
https://downloads.haskell.org/~ghc/9.0.1/docs/html/users_guide/debugging.html
-ddump-timings


# 
cabal haddock --executables

# Lenses
~. -> view

# Debug
https://wiki.haskell.org/Debugging
Recent versions of GHC allow a dump of a stack trace (of all cost centres) when an exception is raised. In order to enable this, compile with -prof, and run with +RTS -xc
import Debug.Trace
traceShow / traceId

# ghci 
use `:script` to load redundant commands

# Frames

inCoreSoA
AoS = Array of Structures

# Multiline strings
        colNames = "age, workclass, fnlwgt, education, education-num, \
                   \marital-status, occupation, relationship, race, sex, \
                   \capital-gain, capital-loss, hours-per-week, \
                   \native-country\n"

# Template Haskell
(the double tick indicates we want the name of the type, not the type itself).


data ElField (field :: (Symbol, Type)) where
with constructor 'Field'
https://hackage.haskell.org/package/vinyl-0.13.0/docs/Data-Vinyl-Functor.html#t:ElField

# polysemy
Effects which don't make use of the m parameter are known as "first-order effects."


https://ghc.gitlab.haskell.org/ghc/doc/users_guide/packages.html#envvar-GHC_PACKAGE_PATH

* working with strings

import Data.ByteString.Lazy as BL
import Data.ByteString as BS
import Data.Text as TS
import Data.Text.Lazy as TL
import Data.ByteString.Lazy.UTF8 as BLU -- from utf8-string
import Data.ByteString.UTF8 as BSU      -- from utf8-string
import Data.Text.Encoding as TSE
import Data.Text.Lazy.Encoding as TLE

-- String <-> ByteString

BLU.toString   :: BL.ByteString -> String
BLU.fromString :: String -> BL.ByteString
BSU.toString   :: BS.ByteString -> String
BSU.fromString :: String -> BS.ByteString

-- String <-> Text

TL.unpack :: TL.Text -> String
TL.pack   :: String -> TL.Text
TS.unpack :: TS.Text -> String
TS.pack   :: String -> TS.Text

-- ByteString <-> Text

TLE.encodeUtf8 :: TL.Text -> BL.ByteString
TLE.decodeUtf8 :: BL.ByteString -> TL.Text
TSE.encodeUtf8 :: TS.Text -> BS.ByteString
TSE.decodeUtf8 :: BS.ByteString -> TS.Text

-- Lazy <-> Strict

BL.fromStrict :: BS.ByteString -> BL.ByteString
BL.toStrict   :: BL.ByteString -> BS.ByteString
TL.fromStrict :: TS.Text -> TL.Text
TL.toStrict   :: TL.Text -> TS.Text

